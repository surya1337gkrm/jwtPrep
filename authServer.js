//JWT[ JSON Web Token ]
//It can be stored on the client side unlike session mnagement authentication we dont have to store the session keys on the server/db.
//...JWT has 3 parts seperated by periods
// JWT KEY: <header info>.<payload/user information>.<signature>
//header info: type of hashing and type of key
//payload consists data we want to send to server/client
//Signature is hash which is generated by hashing thr header and payload with a secret key
//...so that if the data changes, signature will become invalid, thus helps in authentication

//because jwt will have the necessary data, one jwt token can be used top login to diff servers that shares the same secret key
//Refer: https://www.youtube.com/watch?v=7Q17ubqLfaM&ab_channel=WebDevSimplified

//load env variables
require('dotenv').config();

const express = require('express');
const app = express();
const jwt = require('jsonwebtoken');
//to let the app use json
app.use(express.json());

//never store tokens in localStorage, always prefer storing these tokens in db/cache
let refreshTokens = [];

const generateAccessToken = (user) => {
  //to expire a token, we need to pass expiresIn value
  return jwt.sign(user, process.env.ACCESS_TOKEN_SECRET, { expiresIn: '15s' });
};

//generate a new accessToken using refreshToken
app.post('/token', (req, res, next) => {
  const refreshToken = req.body.token;
  //console.log(refreshToken)
  if (refreshToken == null) return res.sendStatus(401);
  if (!refreshTokens.includes(refreshToken)) res.sendStatus(403);
  jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    //if valid, create a new access Token
    //dont pass the user obj directly, as it will contain additonal information which isnt necessary
    const accessToken = generateAccessToken({ name: user.name });
    res.json({ accessToken });
  });
});

app.post('/login', (req, res, next) => {
  //handle the authentication: Login part
  const username = req.body.username;
  const user = { name: username };

  //use jwt package to create a jwt token.
  const accessToken = generateAccessToken(user);
  //dont pass the expiration as we will manually handles the expirration of refreshToken
  const refreshToken = jwt.sign(user, process.env.REFRESH_TOKEN_SECRET);
  refreshTokens.push(refreshToken);
  res.json({ accessToken, refreshToken });
});

//if we just store refreshTokens without deleting, if this toekn is compromised user can create as many access...
//...tokens as possinble. so to avoid, we need to deAuthenticate these refreshTokens whenever a user loggedout.
app.delete('/logout', (req, res, next) => {
  refreshTokens = refreshTokens.filter((token) => token !== req.body.token);
  res.sendStatus(204);
});

app.listen(4000, () => {
  console.log('Listening on Port 4000');
});

//create random strings using crypto library in node
// const crypto = require('crypto');
// console.log(crypto.randomBytes(64).toString('hex').substring(1, 15));

//If we dont expire our access tokens, anyone with accessToken can access our application forever...
//...as the user as long as they have the access token.
//We use refreshTOkens to solve this :
//we save refreshTokens in a safe spot like a DB and expire accessTokens with short time and if
//we need to create a new accessToken we need a refreshToken.So, even if our accessToken is compromised, it will be
//expired and we need refreshToken to create a new accessToken.

//we need to invalidate/delete refreshTokens once user logs out.
//we need to seperate our authentication logic and rest of the routes as if we need to scale, then we can concentrate on one feature.
//or microservice instead of focusing on entire application.[Decoupling]
